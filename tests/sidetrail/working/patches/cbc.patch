diff --git a/tls/s2n_cbc.c b/tls/s2n_cbc.c
index 89904ae73..1f5f281b5 100644
--- a/tests/sidetrail/working/s2n-cbc/tls/s2n_cbc.c
+++ b/tests/sidetrail/working/s2n-cbc/tls/s2n_cbc.c
@@ -23,6 +23,28 @@
 #include "utils/s2n_mem.h"
 #include "utils/s2n_safety.h"
 
+#include <smack.h>
+#include <smack-contracts.h>
+#include "ct-verif.h"
+#include "sidetrail.h"
+
+/* Because of a bug in SMACK, when we try to specify the invarients for this loop in the main function,
+ * SMACK crashes. Moving the code (unmodified) to this function sidesteps the bug. Michael Emmi has promissed
+ * a fix soon
+ */
+int double_loop(int old_mismatches, struct s2n_blob *decrypted, int check, int cutoff, int padding_length) {
+  __VERIFIER_assert(decrypted->size >= 0);
+  __VERIFIER_assert(decrypted->size <= MAX_SIZE);
+  int mismatches = old_mismatches;
+  for (uint32_t i = 0, j = decrypted->size - 1 - check; i < check && j < decrypted->size; i++, j++) {
+    invariant(i <= check);
+    invariant(j == i + decrypted->size - check - 1);
+    uint8_t mask = ~(0xff << ((i >= cutoff) * 8));
+    mismatches |= (decrypted->data[j] ^ padding_length) & mask;
+  }
+  return mismatches;
+}
+
 /* A TLS CBC record looks like ..
  *
  * [ Payload data ] [ HMAC ] [ Padding ] [ Padding length byte ]
@@ -46,17 +68,20 @@
 int s2n_verify_cbc(struct s2n_connection *conn, struct s2n_hmac_state *hmac, struct s2n_blob *sequence_number,
         struct s2n_blob *record_header, struct s2n_blob *decrypted)
 {
-    uint8_t mac_digest_size = 0;
-    POSIX_GUARD(s2n_hmac_digest_size(hmac->alg, &mac_digest_size));
+    uint8_t mac_digest_size = DIGEST_SIZE;
+    //POSIX_GUARD(s2n_hmac_digest_size(hmac->alg, &mac_digest_size));
 
     /* The record has to be at least big enough to contain the MAC,
      * plus the padding length byte */
     POSIX_ENSURE_GT(decrypted->size, mac_digest_size);
 
     int payload_and_padding_size = decrypted->size - mac_digest_size;
+    __VERIFIER_assert(payload_and_padding_size <= MAX_SIZE - 20);
 
     /* Determine what the padding length is */
     uint8_t padding_length = decrypted->data[decrypted->size - 1];
+    __VERIFIER_assume(padding_length >= 0);
+    __VERIFIER_assume(padding_length <  256);
 
     int payload_length = MAX(payload_and_padding_size - padding_length - 1, 0);
     struct s2n_blob plaintext = { 0 };
@@ -73,6 +98,8 @@ int s2n_verify_cbc(struct s2n_connection *conn, struct s2n_hmac_state *hmac, str
     uint32_t currently_in_hash_block = 0;
     POSIX_GUARD_RESULT(s2n_record_write_mac(conn, hmac, sequence_number, record_header, &plaintext,
             &digest_stuffer, &bytes_written, &currently_in_hash_block));
+    __VERIFIER_assume(currently_in_hash_block >= 0);
+    __VERIFIER_assume(currently_in_hash_block < BLOCK_SIZE);
 
     int mismatches = s2n_constant_time_equals(decrypted->data + payload_length, check_digest, mac_digest_size) ^ 1;
 
@@ -83,9 +110,9 @@ int s2n_verify_cbc(struct s2n_connection *conn, struct s2n_hmac_state *hmac, str
     POSIX_GUARD(s2n_hmac_update(hmac, decrypted->data + payload_length + mac_digest_size, decrypted->size - payload_length - mac_digest_size - 1));
 
     /* SSLv3 doesn't specify what the padding should actually be */
-    if (conn->actual_protocol_version == S2N_SSLv3) {
-        return 0 - mismatches;
-    }
+    //if (conn->actual_protocol_version == S2N_SSLv3) {
+    //    return 0 - mismatches;
+    //}
 
     /* Check the maximum amount that could theoretically be padding */
     uint32_t check = MIN(255, (payload_and_padding_size - 1));
@@ -93,10 +120,11 @@ int s2n_verify_cbc(struct s2n_connection *conn, struct s2n_hmac_state *hmac, str
     POSIX_ENSURE_GTE(check, padding_length);
 
     uint32_t cutoff = check - padding_length;
-    for (size_t i = 0, j = decrypted->size - 1 - check; i < check && j < decrypted->size; i++, j++) {
-        uint8_t mask = ~(0xff << ((i >= cutoff) * 8));
-        mismatches |= (decrypted->data[j] ^ padding_length) & mask;
-    }
+    mismatches = double_loop(mismatches, decrypted, check, cutoff, padding_length);
+    //for (size_t i = 0, j = decrypted->size - 1 - check; i < check && j < decrypted->size; i++, j++) {
+    //    uint8_t mask = ~(0xff << ((i >= cutoff) * 8));
+    //    mismatches |= (decrypted->data[j] ^ padding_length) & mask;
+    //}
 
     S2N_ERROR_IF(mismatches, S2N_ERR_CBC_VERIFY);
 
